## IronPython

import os
import csv
import math
from DWSIM.Thermodynamics import *

# Parâmetros cinéticos
k1 = 3.737e5  # mol·Pa^0.5/g·s
E_k1 = 240100  # J/mol
K1 = 8.05e22  # Pa^2 ajustado (verificar), dimensionless intended
E_K1 = 220200  # J/mol (corrigido de J/mol·K)
R = 8.314  # J/mol·K

# Constantes de adsorção
A_CO, Ea_CO = 8.12e-10, 70650  # K_CO: Pa^-1 | J/mol
A_H2, Ea_H2 = 6.04e-10, 82900  # K_H2: Pa^-1 | J/mol
A_CH4, Ea_CH4 = 6.56e-9, 38280  # K_CH4: Pa^-1 | J/mol
A_H2O, Ea_H2O = 1.75e-5, 88680  # K_H2O: Pa (ajustado), J/mol

# Parâmetros do reator
z = Comprimento_metro  # m
D = Diametro_metro  # m
t = Tubos  # número de tubos
N = 50000  # divisões aumentadas para estabilidade
phi = 0.6
rhoc = 100000  # g/m³
T_out = 1103.15  # 830 °C

# Massa total de catalisador (g)
W_total = rhoc*(1 - phi)*z*math.pi*(D**2)/4
dW = W_total/N

# Corrente de entrada
feed = ims1
molflow_in = feed.GetProp("totalFlow", "Overall", None, "", "mole")[0]  # mol/s
T_in = feed.GetProp("temperature", "Overall", None, "", "")[0]  # K
P_in = feed.GetProp("pressure", "Overall", None, "", "")[0]  # Pa
X_in = feed.GetProp("fraction", "Overall", None, "", "mole")  # [CO, CO2, H2, H2O, CH4]

# Verificar frações molares iniciais
if X_in[3] == 0 or X_in[4] == 0:
    Flowsheet.WriteMessage("Aviso: Fração molar inicial de CH4 ou H2O é zero. A reação MSR não ocorrerá.")

# Inicializar fluxos
F_CO = [molflow_in*X_in[0]/t]  # CO (mol/s por tubo)
F_CO2 = [molflow_in*X_in[1]/t]  # CO2 (inerte)
F_H2 = [molflow_in*X_in[2]/t]  # H2
F_H2O = [molflow_in*X_in[3]/t]  # H2O
F_CH4 = [molflow_in*X_in[4]/t]  # CH4
T = [T_in]

# Perfil com pressões parciais, temperatura e calor adicionado
perfil = [["Massa Catalisador (g)", "F_CH4 (mol/s)", "F_H2", "F_CO2", "F_H2O", "F_CO", "P_CH4 (bar)", "P_H2 (bar)", "P_CO2 (bar)", "P_H2O (bar)", "P_CO (bar)", "T (K)", "Q (J/g·s)"]]

def get_Cp(component):
    Cp_values = {
        "CH4": 35.7,  # J/mol·K
        "H2": 28.8,
        "CO2": 37.1,
        "H2O": 33.6,
        "CO": 29.1
    }
    return Cp_values.get(component)

def r_LHHW(P_CH4, P_H2O, P_CO, P_H2, T):
    k_1 = k1*math.exp(-E_k1/(R*T))
    K_1 = K1*math.exp(-E_K1/(R*T)) 
    K_CO = A_CO*math.exp(Ea_CO/(R*T))
    K_H2 = A_H2*math.exp(Ea_H2/(R*T))
    K_CH4 = A_CH4*math.exp(Ea_CH4/(R*T))
    K_H2O = A_H2O*math.exp(-Ea_H2O/(R*T)) 
    numerator = k_1*(P_CH4*P_H2O - ((P_H2**3)*P_CO)/K_1)
    DEN = 1 + K_CO*P_CO + K_H2*P_H2 + K_CH4*P_CH4 + (K_H2O*P_H2O/P_H2 if P_H2 > 0 else 0)
    r = numerator/((DEN**2)*(P_H2**2.5 if P_H2 > 0 else 1)) if DEN > 0 else 0
    return r

# Entalpia de reação
delta_Hr = 206000  # J/mol (endotérmica)

# Estimar calor necessário para atingir T_out
Cp_total_aprox = (molflow_in/t)*33.0  # Cp médio ~33 J/mol·K
Q_add = (T_out - T_in)*Cp_total_aprox/W_total  # J/g·s

# Inicializar calor adicionado total (J/s por tubo)
total_Q_tube = 0

for i in range(N):
    F_total = F_CH4[-1] + F_H2[-1] + F_CO2[-1] + F_H2O[-1] + F_CO[-1]
    X_CH4 = F_CH4[-1]/F_total if F_total > 0 else 0
    X_H2 = F_H2[-1]/F_total if F_total > 0 else 0
    X_CO2 = F_CO2[-1]/F_total if F_total > 0 else 0
    X_H2O = F_H2O[-1]/F_total if F_total > 0 else 0
    X_CO = F_CO[-1]/F_total if F_total > 0 else 0
    
    # Pressões parciais em Pa
    P_CH4 = X_CH4*P_in
    P_H2 = X_H2*P_in
    P_CO2 = X_CO2*P_in
    P_H2O = X_H2O*P_in
    P_CO = X_CO*P_in
    
    r = r_LHHW(P_CH4, P_H2O, P_CO, P_H2, T[-1])
    
    # Capacidade calorífica total
    Cp_total = (F_CH4[-1]*get_Cp("CH4") +
                F_H2[-1]*get_Cp("H2") +
                F_CO2[-1]*get_Cp("CO2") +
                F_H2O[-1]*get_Cp("H2O") +
                F_CO[-1]*get_Cp("CO"))
    
    # Balanço de energia
    Q = r*delta_Hr + Q_add  # Calor adicionado (positivo)
    dT_dW = Q/Cp_total if Cp_total > 0 else 0
    T_next = T[-1] + dT_dW*dW
    
    # Acumular calor adicionado (J/s por tubo)
    total_Q_tube += Q*dW
    
    # Atualizar fluxos e temperatura
    F_CH4.append(F_CH4[-1] - r*dW)
    F_H2O.append(F_H2O[-1] - r*dW)
    F_CO.append(F_CO[-1] + r*dW)
    F_H2.append(F_H2[-1] + 3*r*dW)
    F_CO2.append(F_CO2[-1])  # Inerte
    T.append(T_next)
    
    # Pressões parciais em bar
    P_CH4_bar = P_CH4/100000
    P_H2_bar = P_H2/100000
    P_CO2_bar = P_CO2/100000
    P_H2O_bar = P_H2O/100000
    P_CO_bar = P_CO/100000
    
    perfil.append([round((i+1)*dW, 6), F_CH4[-1], F_H2[-1], F_CO2[-1], F_H2O[-1], F_CO[-1], P_CH4_bar, P_H2_bar, P_CO2_bar, P_H2O_bar, P_CO_bar, T[-1], Q])

# Frações molares finais
F_out = [F_CO[-1], F_CO2[-1], F_H2[-1], F_H2O[-1], F_CH4[-1]]
F_total_out = sum(F_out)*t  # Total para todos os tubos
X_out = [fi/sum(F_out) for fi in F_out] if sum(F_out) > 0 else [0, 0, 0, 0, 0]

# Atualizar corrente de saída material
try:
    out_stream = oms1
    out_stream.Clear()
    out_stream.SetProp("totalFlow", "Overall", None, "", "mole", [F_total_out])
    out_stream.SetProp("fraction", "Overall", None, "", "mole", X_out)
    out_stream.SetProp("temperature", "Overall", None, "", "", [T_out])  # Forçar T_out
    out_stream.SetProp("pressure", "Overall", None, "", "", [P_in - 3.33e5])
except Exception as e:
    Flowsheet.WriteMessage(f"Erro ao atualizar saída material: {str(e)}")

# Atualizar corrente de saída de energia
try:
    energy_stream = ies1
    total_Q = total_Q_tube*t  # J/s (W) para todos os tubos
    energy_stream.EnergyFlow = total_Q/1000  # kW
    Flowsheet.WriteMessage(f"Calor adicionado total: {total_Q:.2f} W")
except Exception as e:
    Flowsheet.WriteMessage(f"Erro ao atualizar corrente de energia: {str(e)}")

# Salvar CSV
documents = os.path.join(os.path.expanduser("~"), "Documents")
try:
    with open(os.path.join(documents, "saida_perfil_reator1.csv"), mode='w', newline='') as file:
        writer = csv.writer(file)
        writer.writerows(perfil)
    Flowsheet.WriteMessage("Arquivo CSV salvo em: " + os.path.join(documents, "saida_perfil_reator1.csv"))
except Exception as e:
    Flowsheet.WriteMessage(f"Erro ao salvar CSV: {str(e)}")
